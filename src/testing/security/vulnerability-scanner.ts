import { execSync } from 'child_process'
import { readFileSync, writeFileSync } from 'fs'
import { join } from 'path'

export interface Vulnerability {
  id: string
  title: string
  description: string
  severity: 'critical' | 'high' | 'medium' | 'low'
  cvss: number
  cve?: string
  cwe?: string
  package?: string
  version?: string
  fixedVersion?: string
  location: {
    file: string
    line?: number
    column?: number
  }
  category: 'dependency' | 'code' | 'configuration' | 'infrastructure'
  status: 'open' | 'fixed' | 'accepted' | 'false_positive'
  discoveredAt: Date
  fixedAt?: Date
}

export interface ScanResult {
  scanId: string
  startTime: Date
  endTime: Date
  scanner: string
  target: string
  vulnerabilities: Vulnerability[]
  summary: {
    total: number
    critical: number
    high: number
    medium: number
    low: number
  }
  metadata: Record<string, any>
}

export interface ScanConfig {
  enabledScanners: string[]
  excludePaths: string[]
  severityThreshold: 'low' | 'medium' | 'high' | 'critical'
  maxScanTime: number
  reportFormat: 'json' | 'xml' | 'sarif'
  autoFix: boolean
}

export class VulnerabilityScanner {
  private config: ScanConfig
  private scanHistory: ScanResult[] = []
  private knownVulnerabilities: Map<string, Vulnerability> = new Map()

  constructor(config: ScanConfig) {
    this.config = config
    this.initializeKnownVulnerabilities()
  }

  // Main Scanning Methods
  async runComprehensiveScan(target: string = '.'): Promise<ScanResult> {
    const scanId = this.generateScanId()
    const startTime = new Date()
    
    console.log(`üîç Starting comprehensive security scan: ${scanId}`)
    
    const vulnerabilities: Vulnerability[] = []
    const scanPromises = []

    // Dependency Vulnerability Scanning
    if (this.config.enabledScanners.includes('dependencies')) {
      scanPromises.push(this.scanDependencies(target))
    }

    // Static Application Security Testing (SAST)
    if (this.config.enabledScanners.includes('sast')) {
      scanPromises.push(this.runSASTScan(target))
    }

    // Dynamic Application Security Testing (DAST)
    if (this.config.enabledScanners.includes('dast')) {
      scanPromises.push(this.runDASTScan(target))
    }

    // Infrastructure Security Scanning
    if (this.config.enabledScanners.includes('infrastructure')) {
      scanPromises.push(this.scanInfrastructure(target))
    }

    // Container Security Scanning
    if (this.config.enabledScanners.includes('container')) {
      scanPromises.push(this.scanContainers(target))
    }

    // Configuration Security Scanning
    if (this.config.enabledScanners.includes('configuration')) {
      scanPromises.push(this.scanConfiguration(target))
    }

    // Execute all scans in parallel
    const scanResults = await Promise.allSettled(scanPromises)
    
    // Collect vulnerabilities from all scans
    scanResults.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        vulnerabilities.push(...result.value)
      } else {
        console.error(`Scan ${index} failed:`, result.reason)
      }
    })

    // Deduplicate and prioritize vulnerabilities
    const uniqueVulnerabilities = this.deduplicateVulnerabilities(vulnerabilities)
    const filteredVulnerabilities = this.filterBySeverity(uniqueVulnerabilities)

    const endTime = new Date()
    const scanResult: ScanResult = {
      scanId,
      startTime,
      endTime,
      scanner: 'comprehensive',
      target,
      vulnerabilities: filteredVulnerabilities,
      summary: this.generateSummary(filteredVulnerabilities),
      metadata: {
        scanDuration: endTime.getTime() - startTime.getTime(),
        scannersUsed: this.config.enabledScanners,
        totalVulnerabilities: vulnerabilities.length,
        uniqueVulnerabilities: uniqueVulnerabilities.length
      }
    }

    this.scanHistory.push(scanResult)
    await this.generateReport(scanResult)

    // Auto-fix if enabled
    if (this.config.autoFix) {
      await this.autoFixVulnerabilities(filteredVulnerabilities)
    }

    console.log(`‚úÖ Security scan completed: ${filteredVulnerabilities.length} vulnerabilities found`)
    return scanResult
  }

  // Dependency Vulnerability Scanning
  async scanDependencies(target: string): Promise<Vulnerability[]> {
    console.log('üîç Scanning dependencies for vulnerabilities...')
    const vulnerabilities: Vulnerability[] = []

    try {
      // Run npm audit
      const auditResult = this.runNpmAudit(target)
      vulnerabilities.push(...this.parseNpmAudit(auditResult))

      // Run yarn audit if yarn.lock exists
      if (this.fileExists(join(target, 'yarn.lock'))) {
        const yarnAuditResult = this.runYarnAudit(target)
        vulnerabilities.push(...this.parseYarnAudit(yarnAuditResult))
      }

      // Check for known vulnerable packages
      vulnerabilities.push(...await this.checkKnownVulnerablePackages(target))

      // License compliance check
      vulnerabilities.push(...await this.checkLicenseCompliance(target))

    } catch (error) {
      console.error('Dependency scan failed:', error)
    }

    return vulnerabilities
  }

  // Static Application Security Testing (SAST)
  async runSASTScan(target: string): Promise<Vulnerability[]> {
    console.log('üîç Running static application security testing...')
    const vulnerabilities: Vulnerability[] = []

    try {
      // Security anti-patterns
      vulnerabilities.push(...await this.scanSecurityAntiPatterns(target))

      // Input validation issues
      vulnerabilities.push(...await this.scanInputValidation(target))

      // Authentication/Authorization flaws
      vulnerabilities.push(...await this.scanAuthFlaws(target))

      // Cryptography issues
      vulnerabilities.push(...await this.scanCryptographyIssues(target))

      // SQL injection vulnerabilities
      vulnerabilities.push(...await this.scanSQLInjection(target))

      // XSS vulnerabilities
      vulnerabilities.push(...await this.scanXSSVulnerabilities(target))

      // CSRF vulnerabilities
      vulnerabilities.push(...await this.scanCSRFVulnerabilities(target))

      // Secrets in code
      vulnerabilities.push(...await this.scanSecretsInCode(target))

    } catch (error) {
      console.error('SAST scan failed:', error)
    }

    return vulnerabilities
  }

  // Dynamic Application Security Testing (DAST)
  async runDASTScan(target: string): Promise<Vulnerability[]> {
    console.log('üîç Running dynamic application security testing...')
    const vulnerabilities: Vulnerability[] = []

    try {
      // Note: This would typically require a running application
      // For demonstration, we'll simulate common DAST checks

      // Authentication bypass
      vulnerabilities.push(...await this.testAuthenticationBypass())

      // Authorization flaws
      vulnerabilities.push(...await this.testAuthorizationFlaws())

      // Input validation
      vulnerabilities.push(...await this.testInputValidation())

      // Session management
      vulnerabilities.push(...await this.testSessionManagement())

      // Error handling
      vulnerabilities.push(...await this.testErrorHandling())

      // HTTP security headers
      vulnerabilities.push(...await this.testSecurityHeaders())

    } catch (error) {
      console.error('DAST scan failed:', error)
    }

    return vulnerabilities
  }

  // Infrastructure Security Scanning
  async scanInfrastructure(target: string): Promise<Vulnerability[]> {
    console.log('üîç Scanning infrastructure security...')
    const vulnerabilities: Vulnerability[] = []

    try {
      // Docker security
      vulnerabilities.push(...await this.scanDockerSecurity(target))

      // Kubernetes security
      vulnerabilities.push(...await this.scanKubernetesSecurity(target))

      // Cloud configuration
      vulnerabilities.push(...await this.scanCloudConfiguration(target))

      // Network configuration
      vulnerabilities.push(...await this.scanNetworkConfiguration(target))

      // SSL/TLS configuration
      vulnerabilities.push(...await this.scanSSLConfiguration(target))

    } catch (error) {
      console.error('Infrastructure scan failed:', error)
    }

    return vulnerabilities
  }

  // Container Security Scanning
  async scanContainers(target: string): Promise<Vulnerability[]> {
    console.log('üîç Scanning container security...')
    const vulnerabilities: Vulnerability[] = []

    try {
      // Dockerfile security
      vulnerabilities.push(...await this.scanDockerfile(target))

      // Base image vulnerabilities
      vulnerabilities.push(...await this.scanBaseImages(target))

      // Container runtime security
      vulnerabilities.push(...await this.scanContainerRuntime(target))

    } catch (error) {
      console.error('Container scan failed:', error)
    }

    return vulnerabilities
  }

  // Configuration Security Scanning
  async scanConfiguration(target: string): Promise<Vulnerability[]> {
    console.log('üîç Scanning configuration security...')
    const vulnerabilities: Vulnerability[] = []

    try {
      // Environment variables
      vulnerabilities.push(...await this.scanEnvironmentVariables(target))

      // Configuration files
      vulnerabilities.push(...await this.scanConfigurationFiles(target))

      // Security misconfigurations
      vulnerabilities.push(...await this.scanSecurityMisconfigurations(target))

    } catch (error) {
      console.error('Configuration scan failed:', error)
    }

    return vulnerabilities
  }

  // SAST Implementation Methods
  private async scanSecurityAntiPatterns(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []
    const patterns = [
      {
        pattern: /eval\s*\(/g,
        severity: 'high' as const,
        title: 'Use of eval() function',
        description: 'eval() can execute arbitrary code and should be avoided',
        cwe: 'CWE-95'
      },
      {
        pattern: /innerHTML\s*=/g,
        severity: 'medium' as const,
        title: 'Use of innerHTML',
        description: 'innerHTML can lead to XSS vulnerabilities',
        cwe: 'CWE-79'
      },
      {
        pattern: /document\.write\s*\(/g,
        severity: 'medium' as const,
        title: 'Use of document.write',
        description: 'document.write can lead to XSS vulnerabilities',
        cwe: 'CWE-79'
      },
      {
        pattern: /localStorage\.setItem\s*\(\s*['"]\w*password/gi,
        severity: 'high' as const,
        title: 'Password stored in localStorage',
        description: 'Passwords should not be stored in localStorage',
        cwe: 'CWE-256'
      }
    ]

    await this.scanFilesForPatterns(target, patterns, vulnerabilities)
    return vulnerabilities
  }

  private async scanSecretsInCode(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []
    const secretPatterns = [
      {
        pattern: /['"]?[A-Za-z0-9]{20,}['"]?\s*[:=]\s*['"][A-Za-z0-9+/]{40,}={0,2}['"]/g,
        title: 'Potential API key or secret',
        severity: 'critical' as const
      },
      {
        pattern: /sk_live_[a-zA-Z0-9]{24,}/g,
        title: 'Stripe live secret key',
        severity: 'critical' as const
      },
      {
        pattern: /pk_live_[a-zA-Z0-9]{24,}/g,
        title: 'Stripe live publishable key',
        severity: 'high' as const
      },
      {
        pattern: /AKIA[0-9A-Z]{16}/g,
        title: 'AWS Access Key ID',
        severity: 'critical' as const
      },
      {
        pattern: /-----BEGIN (RSA )?PRIVATE KEY-----/g,
        title: 'Private key in code',
        severity: 'critical' as const
      }
    ]

    await this.scanFilesForPatterns(target, secretPatterns, vulnerabilities)
    return vulnerabilities
  }

  private async scanSQLInjection(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []
    const sqlPatterns = [
      {
        pattern: /query\s*\(\s*['"`][^'"`]*\$\{[^}]+\}[^'"`]*['"`]/g,
        title: 'Potential SQL injection',
        description: 'String concatenation in SQL queries can lead to injection',
        severity: 'high' as const,
        cwe: 'CWE-89'
      },
      {
        pattern: /['"`]\s*\+\s*\w+\s*\+\s*['"`]/g,
        title: 'String concatenation in query',
        description: 'Use parameterized queries instead of string concatenation',
        severity: 'medium' as const,
        cwe: 'CWE-89'
      }
    ]

    await this.scanFilesForPatterns(target, sqlPatterns, vulnerabilities)
    return vulnerabilities
  }

  // DAST Implementation Methods
  private async testAuthenticationBypass(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []
    
    // Simulate authentication bypass tests
    const tests = [
      {
        test: 'SQL injection in login',
        payload: "admin'--",
        expected: 'login failure',
        severity: 'critical' as const
      },
      {
        test: 'Empty password login',
        payload: '',
        expected: 'login failure',
        severity: 'high' as const
      }
    ]

    // In a real implementation, these would make actual HTTP requests
    for (const test of tests) {
      vulnerabilities.push({
        id: this.generateVulnId(),
        title: `Authentication bypass: ${test.test}`,
        description: `Potential authentication bypass vulnerability`,
        severity: test.severity,
        cvss: this.severityToCVSS(test.severity),
        location: { file: 'authentication endpoint' },
        category: 'code',
        status: 'open',
        discoveredAt: new Date(),
        cwe: 'CWE-287'
      })
    }

    return vulnerabilities
  }

  private async testSecurityHeaders(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []
    
    const requiredHeaders = [
      { name: 'X-Frame-Options', severity: 'medium' as const },
      { name: 'X-XSS-Protection', severity: 'medium' as const },
      { name: 'X-Content-Type-Options', severity: 'medium' as const },
      { name: 'Strict-Transport-Security', severity: 'high' as const },
      { name: 'Content-Security-Policy', severity: 'high' as const }
    ]

    // In a real implementation, these would check actual HTTP responses
    for (const header of requiredHeaders) {
      vulnerabilities.push({
        id: this.generateVulnId(),
        title: `Missing security header: ${header.name}`,
        description: `The ${header.name} header is not set, which may allow attacks`,
        severity: header.severity,
        cvss: this.severityToCVSS(header.severity),
        location: { file: 'HTTP headers' },
        category: 'configuration',
        status: 'open',
        discoveredAt: new Date()
      })
    }

    return vulnerabilities
  }

  // Utility Methods
  private async scanFilesForPatterns(
    target: string, 
    patterns: Array<{pattern: RegExp, title: string, severity: 'critical' | 'high' | 'medium' | 'low', description?: string, cwe?: string}>,
    vulnerabilities: Vulnerability[]
  ): Promise<void> {
    const files = this.getSourceFiles(target)
    
    for (const file of files) {
      try {
        const content = readFileSync(file, 'utf8')
        const lines = content.split('\n')
        
        for (const patternConfig of patterns) {
          let match
          while ((match = patternConfig.pattern.exec(content)) !== null) {
            const lineNumber = content.substring(0, match.index).split('\n').length
            
            vulnerabilities.push({
              id: this.generateVulnId(),
              title: patternConfig.title,
              description: patternConfig.description || `Security pattern detected: ${patternConfig.title}`,
              severity: patternConfig.severity,
              cvss: this.severityToCVSS(patternConfig.severity),
              cwe: patternConfig.cwe,
              location: {
                file: file.replace(target, ''),
                line: lineNumber,
                column: match.index - content.lastIndexOf('\n', match.index)
              },
              category: 'code',
              status: 'open',
              discoveredAt: new Date()
            })
          }
          
          // Reset regex lastIndex
          patternConfig.pattern.lastIndex = 0
        }
      } catch (error) {
        console.error(`Error scanning file ${file}:`, error)
      }
    }
  }

  private runNpmAudit(target: string): string {
    try {
      return execSync('npm audit --json', { cwd: target, encoding: 'utf8' })
    } catch (error) {
      // npm audit returns non-zero exit code when vulnerabilities are found
      return error.stdout || '{}'
    }
  }

  private parseNpmAudit(auditOutput: string): Vulnerability[] {
    try {
      const audit = JSON.parse(auditOutput)
      const vulnerabilities: Vulnerability[] = []
      
      if (audit.vulnerabilities) {
        for (const [packageName, vuln] of Object.entries(audit.vulnerabilities as any)) {
          vulnerabilities.push({
            id: this.generateVulnId(),
            title: `${packageName}: ${vuln.title || 'Vulnerability'}`,
            description: vuln.overview || 'No description available',
            severity: vuln.severity || 'medium',
            cvss: vuln.cvss?.score || this.severityToCVSS(vuln.severity || 'medium'),
            cve: vuln.cves?.[0],
            cwe: vuln.cwe?.[0],
            package: packageName,
            version: vuln.via?.[0]?.version,
            fixedVersion: vuln.fixAvailable?.version,
            location: { file: 'package.json' },
            category: 'dependency',
            status: 'open',
            discoveredAt: new Date()
          })
        }
      }
      
      return vulnerabilities
    } catch (error) {
      console.error('Failed to parse npm audit output:', error)
      return []
    }
  }

  private runYarnAudit(target: string): string {
    try {
      return execSync('yarn audit --json', { cwd: target, encoding: 'utf8' })
    } catch (error) {
      return error.stdout || '{}'
    }
  }

  private parseYarnAudit(auditOutput: string): Vulnerability[] {
    // Similar implementation to parseNpmAudit but for Yarn format
    return []
  }

  private async checkKnownVulnerablePackages(target: string): Promise<Vulnerability[]> {
    // Check against known vulnerable package database
    return []
  }

  private async checkLicenseCompliance(target: string): Promise<Vulnerability[]> {
    // Check for license compliance issues
    return []
  }

  private getSourceFiles(target: string): string[] {
    try {
      // Get all TypeScript and JavaScript files
      const output = execSync(`find ${target} -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" | grep -v node_modules | grep -v .git`, 
        { encoding: 'utf8' })
      return output.trim().split('\n').filter(f => f.length > 0)
    } catch (error) {
      return []
    }
  }

  private fileExists(path: string): boolean {
    try {
      require('fs').accessSync(path)
      return true
    } catch {
      return false
    }
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>()
    return vulnerabilities.filter(vuln => {
      const key = `${vuln.title}:${vuln.location.file}:${vuln.location.line}`
      if (seen.has(key)) return false
      seen.add(key)
      return true
    })
  }

  private filterBySeverity(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 }
    const threshold = severityOrder[this.config.severityThreshold]
    
    return vulnerabilities.filter(vuln => 
      severityOrder[vuln.severity] >= threshold
    )
  }

  private generateSummary(vulnerabilities: Vulnerability[]): ScanResult['summary'] {
    return {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      medium: vulnerabilities.filter(v => v.severity === 'medium').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length
    }
  }

  private async generateReport(scanResult: ScanResult): Promise<void> {
    const reportPath = `security-report-${scanResult.scanId}.json`
    writeFileSync(reportPath, JSON.stringify(scanResult, null, 2))
    console.log(`üìÑ Security report generated: ${reportPath}`)
  }

  private async autoFixVulnerabilities(vulnerabilities: Vulnerability[]): Promise<void> {
    console.log('üîß Attempting to auto-fix vulnerabilities...')
    
    for (const vuln of vulnerabilities) {
      if (vuln.category === 'dependency' && vuln.fixedVersion) {
        console.log(`üîß Auto-fixing ${vuln.package} to version ${vuln.fixedVersion}`)
        // Implementation would update package.json and run npm install
      }
    }
  }

  private generateScanId(): string {
    return `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private generateVulnId(): string {
    return `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private severityToCVSS(severity: string): number {
    const mapping = { critical: 9.0, high: 7.0, medium: 5.0, low: 3.0 }
    return mapping[severity as keyof typeof mapping] || 5.0
  }

  private initializeKnownVulnerabilities(): void {
    // Initialize database of known vulnerabilities
  }

  // Infrastructure scanning methods (simplified implementations)
  private async scanDockerSecurity(target: string): Promise<Vulnerability[]> { return [] }
  private async scanKubernetesSecurity(target: string): Promise<Vulnerability[]> { return [] }
  private async scanCloudConfiguration(target: string): Promise<Vulnerability[]> { return [] }
  private async scanNetworkConfiguration(target: string): Promise<Vulnerability[]> { return [] }
  private async scanSSLConfiguration(target: string): Promise<Vulnerability[]> { return [] }
  private async scanDockerfile(target: string): Promise<Vulnerability[]> { return [] }
  private async scanBaseImages(target: string): Promise<Vulnerability[]> { return [] }
  private async scanContainerRuntime(target: string): Promise<Vulnerability[]> { return [] }
  private async scanEnvironmentVariables(target: string): Promise<Vulnerability[]> { return [] }
  private async scanConfigurationFiles(target: string): Promise<Vulnerability[]> { return [] }
  private async scanSecurityMisconfigurations(target: string): Promise<Vulnerability[]> { return [] }
  private async scanInputValidation(target: string): Promise<Vulnerability[]> { return [] }
  private async scanAuthFlaws(target: string): Promise<Vulnerability[]> { return [] }
  private async scanCryptographyIssues(target: string): Promise<Vulnerability[]> { return [] }
  private async scanXSSVulnerabilities(target: string): Promise<Vulnerability[]> { return [] }
  private async scanCSRFVulnerabilities(target: string): Promise<Vulnerability[]> { return [] }
  private async testAuthorizationFlaws(): Promise<Vulnerability[]> { return [] }
  private async testInputValidation(): Promise<Vulnerability[]> { return [] }
  private async testSessionManagement(): Promise<Vulnerability[]> { return [] }
  private async testErrorHandling(): Promise<Vulnerability[]> { return [] }

  // Public API
  getScanHistory(): ScanResult[] {
    return [...this.scanHistory].sort((a, b) => b.startTime.getTime() - a.startTime.getTime())
  }

  getVulnerabilityById(id: string): Vulnerability | undefined {
    for (const scan of this.scanHistory) {
      const vuln = scan.vulnerabilities.find(v => v.id === id)
      if (vuln) return vuln
    }
    return undefined
  }

  async markVulnerabilityFixed(id: string): Promise<void> {
    const vuln = this.getVulnerabilityById(id)
    if (vuln) {
      vuln.status = 'fixed'
      vuln.fixedAt = new Date()
      console.log(`‚úÖ Vulnerability ${id} marked as fixed`)
    }
  }

  getSecurityMetrics(): {
    totalScans: number
    totalVulnerabilities: number
    openVulnerabilities: number
    fixedVulnerabilities: number
    averageScanTime: number
    severityDistribution: Record<string, number>
  } {
    const allVulns = this.scanHistory.flatMap(scan => scan.vulnerabilities)
    const openVulns = allVulns.filter(v => v.status === 'open')
    const fixedVulns = allVulns.filter(v => v.status === 'fixed')
    const avgScanTime = this.scanHistory.reduce((sum, scan) => 
      sum + (scan.endTime.getTime() - scan.startTime.getTime()), 0) / this.scanHistory.length

    const severityDistribution = allVulns.reduce((acc, vuln) => {
      acc[vuln.severity] = (acc[vuln.severity] || 0) + 1
      return acc
    }, {} as Record<string, number>)

    return {
      totalScans: this.scanHistory.length,
      totalVulnerabilities: allVulns.length,
      openVulnerabilities: openVulns.length,
      fixedVulnerabilities: fixedVulns.length,
      averageScanTime: avgScanTime || 0,
      severityDistribution
    }
  }
}